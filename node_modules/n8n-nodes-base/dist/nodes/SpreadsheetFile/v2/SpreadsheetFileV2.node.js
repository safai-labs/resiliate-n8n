"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SpreadsheetFileV2 = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const xlsx_1 = require("xlsx");
const csv_parse_1 = require("csv-parse");
const description_1 = require("../description");
const utilities_1 = require("../../../utils/utilities");
class SpreadsheetFileV2 {
    constructor(baseDescription) {
        this.description = {
            ...baseDescription,
            version: 2,
            defaults: {
                name: 'Spreadsheet File',
                color: '#2244FF',
            },
            inputs: ['main'],
            outputs: ['main'],
            properties: [
                ...description_1.operationProperties,
                ...description_1.fromFileProperties,
                ...description_1.fromFileV2Properties,
                ...description_1.toFileProperties,
                ...description_1.optionsProperties,
            ],
        };
    }
    async execute() {
        const items = this.getInputData();
        const operation = this.getNodeParameter('operation', 0);
        const newItems = [];
        if (operation === 'fromFile') {
            for (let i = 0; i < items.length; i++) {
                try {
                    const options = this.getNodeParameter('options', i, {});
                    let fileFormat = this.getNodeParameter('fileFormat', i, {});
                    const binaryPropertyName = this.getNodeParameter('binaryPropertyName', i);
                    const binaryData = this.helpers.assertBinaryData(i, binaryPropertyName);
                    let rows = [];
                    if (fileFormat === 'autodetect' &&
                        (binaryData.mimeType === 'text/csv' ||
                            (binaryData.mimeType === 'text/plain' && binaryData.fileExtension === 'csv'))) {
                        fileFormat = 'csv';
                    }
                    if (fileFormat === 'csv') {
                        const maxRowCount = options.maxRowCount;
                        const parser = (0, csv_parse_1.parse)({
                            delimiter: options.delimiter,
                            fromLine: options.fromLine,
                            bom: options.enableBOM,
                            to: maxRowCount > -1 ? maxRowCount : undefined,
                            columns: options.headerRow !== false,
                            onRecord: (record) => {
                                if (!options.includeEmptyCells) {
                                    record = Object.fromEntries(Object.entries(record).filter(([_key, value]) => value !== ''));
                                }
                                rows.push(record);
                            },
                        });
                        if (binaryData.id) {
                            const stream = await this.helpers.getBinaryStream(binaryData.id);
                            await new Promise(async (resolve, reject) => {
                                parser.on('error', reject);
                                parser.on('readable', () => {
                                    stream.unpipe(parser);
                                    stream.destroy();
                                    resolve();
                                });
                                stream.pipe(parser);
                            });
                        }
                        else {
                            parser.write(binaryData.data, n8n_workflow_1.BINARY_ENCODING);
                            parser.end();
                        }
                    }
                    else {
                        let workbook;
                        const xlsxOptions = { raw: options.rawData };
                        if (options.readAsString)
                            xlsxOptions.type = 'string';
                        if (binaryData.id) {
                            const binaryPath = this.helpers.getBinaryPath(binaryData.id);
                            workbook = (0, xlsx_1.readFile)(binaryPath, xlsxOptions);
                        }
                        else {
                            const binaryDataBuffer = Buffer.from(binaryData.data, n8n_workflow_1.BINARY_ENCODING);
                            workbook = (0, xlsx_1.read)(options.readAsString ? binaryDataBuffer.toString() : binaryDataBuffer, xlsxOptions);
                        }
                        if (workbook.SheetNames.length === 0) {
                            throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Spreadsheet does not have any sheets!', {
                                itemIndex: i,
                            });
                        }
                        let sheetName = workbook.SheetNames[0];
                        if (options.sheetName) {
                            if (!workbook.SheetNames.includes(options.sheetName)) {
                                throw new n8n_workflow_1.NodeOperationError(this.getNode(), `Spreadsheet does not contain sheet called "${options.sheetName}"!`, { itemIndex: i });
                            }
                            sheetName = options.sheetName;
                        }
                        const sheetToJsonOptions = {};
                        if (options.range) {
                            if (isNaN(options.range)) {
                                sheetToJsonOptions.range = options.range;
                            }
                            else {
                                sheetToJsonOptions.range = parseInt(options.range, 10);
                            }
                        }
                        if (options.includeEmptyCells) {
                            sheetToJsonOptions.defval = '';
                        }
                        if (options.headerRow === false) {
                            sheetToJsonOptions.header = 1;
                        }
                        rows = xlsx_1.utils.sheet_to_json(workbook.Sheets[sheetName], sheetToJsonOptions);
                        if (rows.length === 0) {
                            continue;
                        }
                    }
                    if (options.headerRow === false) {
                        for (const rowData of rows) {
                            newItems.push({
                                json: {
                                    row: rowData,
                                },
                                pairedItem: {
                                    item: i,
                                },
                            });
                        }
                    }
                    else {
                        for (const rowData of rows) {
                            newItems.push({
                                json: rowData,
                                pairedItem: {
                                    item: i,
                                },
                            });
                        }
                    }
                }
                catch (error) {
                    if (this.continueOnFail()) {
                        newItems.push({
                            json: {
                                error: error.message,
                            },
                            pairedItem: {
                                item: i,
                            },
                        });
                        continue;
                    }
                    throw new n8n_workflow_1.NodeOperationError(this.getNode(), error, { itemIndex: i });
                }
            }
            return [newItems];
        }
        else if (operation === 'toFile') {
            const pairedItem = (0, utilities_1.generatePairedItemData)(items.length);
            try {
                const binaryPropertyName = this.getNodeParameter('binaryPropertyName', 0);
                const fileFormat = this.getNodeParameter('fileFormat', 0);
                const options = this.getNodeParameter('options', 0, {});
                const sheetToJsonOptions = {};
                if (options.headerRow === false) {
                    sheetToJsonOptions.skipHeader = true;
                }
                let item;
                const itemData = [];
                for (let itemIndex = 0; itemIndex < items.length; itemIndex++) {
                    item = items[itemIndex];
                    itemData.push((0, utilities_1.flattenObject)(item.json));
                }
                const ws = xlsx_1.utils.json_to_sheet(itemData, sheetToJsonOptions);
                const wopts = {
                    bookSST: false,
                    type: 'buffer',
                };
                if (fileFormat === 'csv') {
                    wopts.bookType = 'csv';
                }
                else if (fileFormat === 'html') {
                    wopts.bookType = 'html';
                }
                else if (fileFormat === 'rtf') {
                    wopts.bookType = 'rtf';
                }
                else if (fileFormat === 'ods') {
                    wopts.bookType = 'ods';
                    if (options.compression) {
                        wopts.compression = true;
                    }
                }
                else if (fileFormat === 'xls') {
                    wopts.bookType = 'xls';
                }
                else if (fileFormat === 'xlsx') {
                    wopts.bookType = 'xlsx';
                    if (options.compression) {
                        wopts.compression = true;
                    }
                }
                const sheetName = options.sheetName || 'Sheet';
                const wb = {
                    SheetNames: [sheetName],
                    Sheets: {
                        [sheetName]: ws,
                    },
                };
                const wbout = (0, xlsx_1.write)(wb, wopts);
                const newItem = {
                    json: {},
                    binary: {},
                    pairedItem,
                };
                let fileName = `spreadsheet.${fileFormat}`;
                if (options.fileName !== undefined) {
                    fileName = options.fileName;
                }
                newItem.binary[binaryPropertyName] = await this.helpers.prepareBinaryData(wbout, fileName);
                newItems.push(newItem);
            }
            catch (error) {
                if (this.continueOnFail()) {
                    newItems.push({
                        json: {
                            error: error.message,
                        },
                        pairedItem,
                    });
                }
                else {
                    throw error;
                }
            }
        }
        else {
            if (this.continueOnFail()) {
                return [[{ json: { error: `The operation "${operation}" is not supported!` } }]];
            }
            else {
                throw new n8n_workflow_1.NodeOperationError(this.getNode(), `The operation "${operation}" is not supported!`);
            }
        }
        return [newItems];
    }
}
exports.SpreadsheetFileV2 = SpreadsheetFileV2;
//# sourceMappingURL=SpreadsheetFileV2.node.js.map