"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeSSLError = exports.NodeApiError = exports.NodeOperationError = exports.NodeError = exports.ExecutionBaseError = void 0;
const xml2js_1 = require("xml2js");
const utils_1 = require("./utils");
const ERROR_MESSAGE_PROPERTIES = [
    'cause',
    'error',
    'message',
    'Message',
    'msg',
    'messages',
    'description',
    'reason',
    'detail',
    'details',
    'errors',
    'errorMessage',
    'errorMessages',
    'ErrorMessage',
    'error_message',
    '_error_message',
    'errorDescription',
    'error_description',
    'error_summary',
    'title',
    'text',
    'field',
    'err',
    'type',
];
const ERROR_STATUS_PROPERTIES = [
    'statusCode',
    'status',
    'code',
    'status_code',
    'errorCode',
    'error_code',
];
const ERROR_NESTING_PROPERTIES = ['error', 'err', 'response', 'body', 'data'];
const COMMON_ERRORS = {
    ECONNREFUSED: 'The service refused the connection - perhaps it is offline',
    ECONNRESET: 'The connection to the server wes closed unexpectedly, perhaps it is offline. You can retry request immidiately or wait and retry later.',
    ENOTFOUND: 'The connection cannot be established, this usually occurs due to an incorrect host(domain) value',
    ETIMEDOUT: "The connection timed out, consider setting 'Retry on Fail' option in the node settings",
    ERRADDRINUSE: 'The port is already occupied by some other application, if possible change the port or kill the application that is using it',
    EADDRNOTAVAIL: 'The address is not available, ensure that you have the right IP address',
    ECONNABORTED: 'The connection was aborted, perhaps the server is offline',
    EHOSTUNREACH: 'The host is unreachable, perhaps the server is offline',
    EAI_AGAIN: 'The DNS server returned an error, perhaps the server is offline',
    ENOENT: 'The file or directory does not exist',
    EISDIR: 'The file path expected but a given path is a directory',
    ENOTDIR: 'The directory path expected but a given path is a file',
    EACCES: 'Forbidden by access permissions, make sure you have the right permissions',
    EEXIST: 'The file or directory already exists',
    EPERM: 'Operation not permitted, make sure you have the right permissions',
    GETADDRINFO: 'The server closed the connection unexpectedly',
};
const STATUS_CODE_MESSAGES = {
    '4XX': 'Your request is invalid or could not be processed by the service',
    '400': 'Bad request - please check your parameters',
    '401': 'Authorization failed - please check your credentials',
    '402': 'Payment required - perhaps check your payment details?',
    '403': 'Forbidden - perhaps check your credentials?',
    '404': 'The resource you are requesting could not be found',
    '405': 'Method not allowed - please check you are using the right HTTP method',
    '429': 'The service is receiving too many requests from you',
    '5XX': 'The service failed to process your request',
    '500': 'The service was not able to process your request',
    '502': 'Bad gateway - the service failed to handle your request',
    '503': 'Service unavailable - try again later or consider setting this node to retry automatically (in the node settings)',
    '504': 'Gateway timed out - perhaps try again later?',
};
const UNKNOWN_ERROR_MESSAGE = 'UNKNOWN ERROR - check the detailed error for more information';
const UNKNOWN_ERROR_MESSAGE_CRED = 'UNKNOWN ERROR';
class ExecutionBaseError extends Error {
    constructor(message, { cause }) {
        const options = cause instanceof Error ? { cause } : {};
        super(message, options);
        this.context = {};
        this.severity = 'error';
        this.name = this.constructor.name;
        this.timestamp = Date.now();
        if (cause instanceof ExecutionBaseError) {
            this.context = cause.context;
        }
        else if (cause && !(cause instanceof Error)) {
            this.cause = cause;
        }
    }
    toJSON() {
        return {
            message: this.message,
            lineNumber: this.lineNumber,
            timestamp: this.timestamp,
            name: this.name,
            description: this.description,
            context: this.context,
            cause: this.cause,
        };
    }
}
exports.ExecutionBaseError = ExecutionBaseError;
class NodeError extends ExecutionBaseError {
    constructor(node, error) {
        const message = error instanceof Error ? error.message : '';
        super(message, { cause: error });
        this.node = node;
    }
    findProperty(jsonError, potentialKeys, traversalKeys = []) {
        for (const key of potentialKeys) {
            const value = jsonError[key];
            if (value) {
                if (typeof value === 'string')
                    return value;
                if (typeof value === 'number')
                    return value.toString();
                if (Array.isArray(value)) {
                    const resolvedErrors = value
                        .map((jsonError) => {
                        if (typeof jsonError === 'string')
                            return jsonError;
                        if (typeof jsonError === 'number')
                            return jsonError.toString();
                        if ((0, utils_1.isTraversableObject)(jsonError)) {
                            return this.findProperty(jsonError, potentialKeys);
                        }
                        return null;
                    })
                        .filter((errorValue) => errorValue !== null);
                    if (resolvedErrors.length === 0) {
                        return null;
                    }
                    return resolvedErrors.join(' | ');
                }
                if ((0, utils_1.isTraversableObject)(value)) {
                    const property = this.findProperty(value, potentialKeys);
                    if (property) {
                        return property;
                    }
                }
            }
        }
        for (const key of traversalKeys) {
            const value = jsonError[key];
            if ((0, utils_1.isTraversableObject)(value)) {
                const property = this.findProperty(value, potentialKeys, traversalKeys);
                if (property) {
                    return property;
                }
            }
        }
        return null;
    }
    setDescriptiveErrorMessage(message, description, code, messageMapping) {
        let newMessage = message;
        let newDescription = description;
        if (messageMapping) {
            for (const [mapKey, mapMessage] of Object.entries(messageMapping)) {
                if ((message || '').toUpperCase().includes(mapKey.toUpperCase())) {
                    newMessage = mapMessage;
                    newDescription = this.updateDescription(message, description);
                    break;
                }
            }
            if (newMessage !== message) {
                return [newMessage, newDescription];
            }
        }
        if (code && COMMON_ERRORS[code.toUpperCase()]) {
            newMessage = COMMON_ERRORS[code];
            newDescription = this.updateDescription(message, description);
            return [newMessage, newDescription];
        }
        for (const [errorCode, errorDescriptiveMessage] of Object.entries(COMMON_ERRORS)) {
            if ((message || '').toUpperCase().includes(errorCode.toUpperCase())) {
                newMessage = errorDescriptiveMessage;
                newDescription = this.updateDescription(message, description);
                break;
            }
        }
        return [newMessage, newDescription];
    }
    updateDescription(message, description) {
        return `${message}${description ? ` - ${description}` : ''}`;
    }
}
exports.NodeError = NodeError;
class NodeOperationError extends NodeError {
    constructor(node, error, options = {}) {
        if (typeof error === 'string') {
            error = new Error(error);
        }
        super(node, error);
        if (options.message)
            this.message = options.message;
        if (options.severity)
            this.severity = options.severity;
        this.description = options.description;
        this.context.runIndex = options.runIndex;
        this.context.itemIndex = options.itemIndex;
        if (this.message === this.description) {
            this.description = undefined;
        }
        [this.message, this.description] = this.setDescriptiveErrorMessage(this.message, this.description, undefined, options.messageMapping);
    }
}
exports.NodeOperationError = NodeOperationError;
class NodeApiError extends NodeError {
    constructor(node, error, { message, description, httpCode, parseXml, runIndex, itemIndex, severity, messageMapping, } = {}) {
        var _a, _b, _c, _d, _e, _f;
        super(node, error);
        if (severity)
            this.severity = severity;
        else if ((httpCode === null || httpCode === void 0 ? void 0 : httpCode.charAt(0)) !== '5')
            this.severity = 'warning';
        if (error.error) {
            (0, utils_1.removeCircularRefs)(error.error);
        }
        if (!description && (error.description || ((_a = error === null || error === void 0 ? void 0 : error.reason) === null || _a === void 0 ? void 0 : _a.description))) {
            this.description = (error.description ||
                ((_b = error === null || error === void 0 ? void 0 : error.reason) === null || _b === void 0 ? void 0 : _b.description));
        }
        if (!message && (error.message || ((_c = error === null || error === void 0 ? void 0 : error.reason) === null || _c === void 0 ? void 0 : _c.message) || description)) {
            this.message = (error.message ||
                ((_d = error === null || error === void 0 ? void 0 : error.reason) === null || _d === void 0 ? void 0 : _d.message) ||
                description);
        }
        if (error.reason) {
            const reason = error.reason;
            if (reason.isAxiosError && reason.response) {
                error = reason.response;
            }
        }
        if (httpCode) {
            this.httpCode = httpCode;
        }
        else {
            this.httpCode =
                (_e = this.findProperty(error, ERROR_STATUS_PROPERTIES, ERROR_NESTING_PROPERTIES)) !== null && _e !== void 0 ? _e : null;
        }
        if (description) {
            this.description = description;
        }
        if (!this.description) {
            if (parseXml) {
                this.setDescriptionFromXml(error.error);
            }
            else {
                this.description = this.findProperty(error, ERROR_MESSAGE_PROPERTIES, ERROR_NESTING_PROPERTIES);
            }
        }
        if (message) {
            this.message = message;
        }
        else {
            this.setDefaultStatusCodeMessage();
        }
        if (this.message === this.description) {
            this.description = undefined;
        }
        [this.message, this.description] = this.setDescriptiveErrorMessage(this.message, this.description, this.httpCode ||
            (error === null || error === void 0 ? void 0 : error.code) ||
            ((_f = error === null || error === void 0 ? void 0 : error.reason) === null || _f === void 0 ? void 0 : _f.code) ||
            undefined, messageMapping);
        if (runIndex !== undefined)
            this.context.runIndex = runIndex;
        if (itemIndex !== undefined)
            this.context.itemIndex = itemIndex;
    }
    setDescriptionFromXml(xml) {
        (0, xml2js_1.parseString)(xml, { explicitArray: false }, (_, result) => {
            if (!result)
                return;
            const topLevelKey = Object.keys(result)[0];
            this.description = this.findProperty(result[topLevelKey], ERROR_MESSAGE_PROPERTIES, ['Error'].concat(ERROR_NESTING_PROPERTIES));
        });
    }
    setDefaultStatusCodeMessage() {
        if (!this.httpCode && this.message && this.message.toLowerCase().includes('bad gateway')) {
            this.httpCode = '502';
        }
        if (!this.httpCode) {
            this.httpCode = null;
            this.message = this.message || this.description || UNKNOWN_ERROR_MESSAGE;
            return;
        }
        if (STATUS_CODE_MESSAGES[this.httpCode]) {
            this.description = this.updateDescription(this.message, this.description);
            this.message = STATUS_CODE_MESSAGES[this.httpCode];
            return;
        }
        switch (this.httpCode.charAt(0)) {
            case '4':
                this.description = this.updateDescription(this.message, this.description);
                this.message = STATUS_CODE_MESSAGES['4XX'];
                break;
            case '5':
                this.description = this.updateDescription(this.message, this.description);
                this.message = STATUS_CODE_MESSAGES['5XX'];
                break;
            default:
                this.message = this.message || this.description || UNKNOWN_ERROR_MESSAGE;
        }
        if (this.node.type === 'n8n-nodes-base.noOp' && this.message === UNKNOWN_ERROR_MESSAGE) {
            this.message = `${UNKNOWN_ERROR_MESSAGE_CRED} - ${this.httpCode}`;
        }
    }
}
exports.NodeApiError = NodeApiError;
class NodeSSLError extends ExecutionBaseError {
    constructor(cause) {
        super("SSL Issue: consider using the 'Ignore SSL issues' option", { cause });
    }
}
exports.NodeSSLError = NodeSSLError;
//# sourceMappingURL=NodeErrors.js.map