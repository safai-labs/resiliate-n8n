"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Webhook = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const promises_1 = require("stream/promises");
const fs_1 = require("fs");
const uuid_1 = require("uuid");
const basic_auth_1 = __importDefault(require("basic-auth"));
const isbot_1 = __importDefault(require("isbot"));
const tmp_promise_1 = require("tmp-promise");
const description_1 = require("./description");
const error_1 = require("./error");
class Webhook extends n8n_workflow_1.Node {
    constructor() {
        super(...arguments);
        this.authPropertyName = 'authentication';
        this.description = {
            displayName: 'Webhook',
            icon: 'file:webhook.svg',
            name: 'webhook',
            group: ['trigger'],
            version: 1,
            description: 'Starts the workflow when a webhook is called',
            eventTriggerDescription: 'Waiting for you to call the Test URL',
            activationMessage: 'You can now make calls to your production webhook URL.',
            defaults: {
                name: 'Webhook',
            },
            triggerPanel: {
                header: '',
                executionsHelp: {
                    inactive: 'Webhooks have two modes: test and production. <br /> <br /> <b>Use test mode while you build your workflow</b>. Click the \'listen\' button, then make a request to the test URL. The executions will show up in the editor.<br /> <br /> <b>Use production mode to run your workflow automatically</b>. <a data-key="activate">Activate</a> the workflow, then make requests to the production URL. These executions will show up in the executions list, but not in the editor.',
                    active: 'Webhooks have two modes: test and production. <br /> <br /> <b>Use test mode while you build your workflow</b>. Click the \'listen\' button, then make a request to the test URL. The executions will show up in the editor.<br /> <br /> <b>Use production mode to run your workflow automatically</b>. Since the workflow is activated, you can make requests to the production URL. These executions will show up in the <a data-key="executions">executions list</a>, but not in the editor.',
                },
                activationHint: 'Once youâ€™ve finished building your workflow, run it without having to click this button by using the production webhook URL.',
            },
            inputs: [],
            outputs: ['main'],
            credentials: (0, description_1.credentialsProperty)(this.authPropertyName),
            webhooks: [description_1.defaultWebhookDescription],
            properties: [
                (0, description_1.authenticationProperty)(this.authPropertyName),
                description_1.httpMethodsProperty,
                {
                    displayName: 'Path',
                    name: 'path',
                    type: 'string',
                    default: '',
                    placeholder: 'webhook',
                    required: true,
                    description: 'The path to listen to',
                },
                description_1.responseModeProperty,
                {
                    displayName: 'Insert a \'Respond to Webhook\' node to control when and how you respond. <a href="https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.respondtowebhook/" target="_blank">More details</a>',
                    name: 'webhookNotice',
                    type: 'notice',
                    displayOptions: {
                        show: {
                            responseMode: ['responseNode'],
                        },
                    },
                    default: '',
                },
                description_1.responseCodeProperty,
                description_1.responseDataProperty,
                description_1.responseBinaryPropertyNameProperty,
                description_1.optionsProperty,
            ],
        };
    }
    async webhook(context) {
        var _a;
        const options = context.getNodeParameter('options', {});
        const req = context.getRequestObject();
        const resp = context.getResponseObject();
        try {
            if (options.ignoreBots && (0, isbot_1.default)(req.headers['user-agent']))
                throw new error_1.WebhookAuthorizationError(403);
            await this.validateAuth(context);
        }
        catch (error) {
            if (error instanceof error_1.WebhookAuthorizationError) {
                resp.writeHead(error.responseCode, { 'WWW-Authenticate': 'Basic realm="Webhook"' });
                resp.end(error.message);
                return { noWebhookResponse: true };
            }
            throw error;
        }
        if (options.binaryData) {
            return this.handleBinaryData(context);
        }
        if (req.contentType === 'multipart/form-data') {
            return this.handleFormData(context);
        }
        const response = {
            json: {
                headers: req.headers,
                params: req.params,
                query: req.query,
                body: req.body,
            },
            binary: options.rawBody
                ? {
                    data: {
                        data: req.rawBody.toString(n8n_workflow_1.BINARY_ENCODING),
                        mimeType: (_a = req.contentType) !== null && _a !== void 0 ? _a : 'application/json',
                    },
                }
                : undefined,
        };
        return {
            webhookResponse: options.responseData,
            workflowData: [[response]],
        };
    }
    async validateAuth(context) {
        const authentication = context.getNodeParameter(this.authPropertyName);
        if (authentication === 'none')
            return;
        const req = context.getRequestObject();
        const headers = context.getHeaderData();
        if (authentication === 'basicAuth') {
            let expectedAuth;
            try {
                expectedAuth = await context.getCredentials('httpBasicAuth');
            }
            catch { }
            if (expectedAuth === undefined || !expectedAuth.user || !expectedAuth.password) {
                throw new error_1.WebhookAuthorizationError(500, 'No authentication data defined on node!');
            }
            const providedAuth = (0, basic_auth_1.default)(req);
            if (!providedAuth)
                throw new error_1.WebhookAuthorizationError(401);
            if (providedAuth.name !== expectedAuth.user || providedAuth.pass !== expectedAuth.password) {
                throw new error_1.WebhookAuthorizationError(403);
            }
        }
        else if (authentication === 'headerAuth') {
            let expectedAuth;
            try {
                expectedAuth = await context.getCredentials('httpHeaderAuth');
            }
            catch { }
            if (expectedAuth === undefined || !expectedAuth.name || !expectedAuth.value) {
                throw new error_1.WebhookAuthorizationError(500, 'No authentication data defined on node!');
            }
            const headerName = expectedAuth.name.toLowerCase();
            const expectedValue = expectedAuth.value;
            if (!headers.hasOwnProperty(headerName) ||
                headers[headerName] !== expectedValue) {
                throw new error_1.WebhookAuthorizationError(403);
            }
        }
    }
    async handleFormData(context) {
        var _a;
        const req = context.getRequestObject();
        const options = context.getNodeParameter('options', {});
        const { data, files } = req.body;
        const returnItem = {
            binary: {},
            json: {
                headers: req.headers,
                params: req.params,
                query: req.query,
                body: data,
            },
        };
        let count = 0;
        for (const key of Object.keys(files)) {
            const processFiles = [];
            let multiFile = false;
            if (Array.isArray(files[key])) {
                processFiles.push(...files[key]);
                multiFile = true;
            }
            else {
                processFiles.push(files[key]);
            }
            let fileCount = 0;
            for (const file of processFiles) {
                let binaryPropertyName = key;
                if (binaryPropertyName.endsWith('[]')) {
                    binaryPropertyName = binaryPropertyName.slice(0, -2);
                }
                if (multiFile) {
                    binaryPropertyName += fileCount++;
                }
                if (options.binaryPropertyName) {
                    binaryPropertyName = `${options.binaryPropertyName}${count}`;
                }
                returnItem.binary[binaryPropertyName] = await context.nodeHelpers.copyBinaryFile(file.filepath, (_a = file.originalFilename) !== null && _a !== void 0 ? _a : file.newFilename, file.mimetype);
                count += 1;
            }
        }
        return { workflowData: [[returnItem]] };
    }
    async handleBinaryData(context) {
        var _a, _b, _c;
        const req = context.getRequestObject();
        const options = context.getNodeParameter('options', {});
        const binaryFile = await (0, tmp_promise_1.file)({ prefix: 'n8n-webhook-' });
        try {
            await (0, promises_1.pipeline)(req, (0, fs_1.createWriteStream)(binaryFile.path));
            const returnItem = {
                binary: {},
                json: {
                    headers: req.headers,
                    params: req.params,
                    query: req.query,
                    body: {},
                },
            };
            const binaryPropertyName = (options.binaryPropertyName || 'data');
            const fileName = (_b = (_a = req.contentDisposition) === null || _a === void 0 ? void 0 : _a.filename) !== null && _b !== void 0 ? _b : (0, uuid_1.v4)();
            returnItem.binary[binaryPropertyName] = await context.nodeHelpers.copyBinaryFile(binaryFile.path, fileName, (_c = req.contentType) !== null && _c !== void 0 ? _c : 'application/octet-stream');
            return { workflowData: [[returnItem]] };
        }
        catch (error) {
            throw new n8n_workflow_1.NodeOperationError(context.getNode(), error);
        }
        finally {
            await binaryFile.cleanup();
        }
    }
}
exports.Webhook = Webhook;
//# sourceMappingURL=Webhook.node.js.map