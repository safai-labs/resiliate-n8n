"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareRequestBody = exports.reduceAsync = exports.binaryContentTypes = exports.getOAuth2AdditionalParameters = exports.sanitizeUiMessage = exports.replaceNullValues = void 0;
const set_1 = __importDefault(require("lodash/set"));
const replaceNullValues = (item) => {
    if (item.json === null) {
        item.json = {};
    }
    return item;
};
exports.replaceNullValues = replaceNullValues;
function sanitizeUiMessage(request, authDataKeys) {
    let sendRequest = request;
    if (Buffer.isBuffer(sendRequest.body) && sendRequest.body.length > 250000) {
        sendRequest = {
            ...request,
            body: `Binary data got replaced with this text. Original was a Buffer with a size of ${request.body.length} byte.`,
        };
    }
    for (const requestProperty of Object.keys(authDataKeys)) {
        sendRequest = {
            ...sendRequest,
            [requestProperty]: Object.keys(sendRequest[requestProperty]).reduce((acc, curr) => {
                acc[curr] = authDataKeys[requestProperty].includes(curr)
                    ? '** hidden **'
                    : sendRequest[requestProperty][curr];
                return acc;
            }, {}),
        };
    }
    return sendRequest;
}
exports.sanitizeUiMessage = sanitizeUiMessage;
const getOAuth2AdditionalParameters = (nodeCredentialType) => {
    const oAuth2Options = {
        bitlyOAuth2Api: {
            tokenType: 'Bearer',
        },
        boxOAuth2Api: {
            includeCredentialsOnRefreshOnBody: true,
        },
        ciscoWebexOAuth2Api: {
            tokenType: 'Bearer',
        },
        clickUpOAuth2Api: {
            keepBearer: false,
            tokenType: 'Bearer',
        },
        goToWebinarOAuth2Api: {
            tokenExpiredStatusCode: 403,
        },
        hubspotDeveloperApi: {
            tokenType: 'Bearer',
            includeCredentialsOnRefreshOnBody: true,
        },
        hubspotOAuth2Api: {
            tokenType: 'Bearer',
            includeCredentialsOnRefreshOnBody: true,
        },
        lineNotifyOAuth2Api: {
            tokenType: 'Bearer',
        },
        linkedInOAuth2Api: {
            tokenType: 'Bearer',
        },
        mailchimpOAuth2Api: {
            tokenType: 'Bearer',
        },
        mauticOAuth2Api: {
            includeCredentialsOnRefreshOnBody: true,
        },
        microsoftDynamicsOAuth2Api: {
            property: 'id_token',
        },
        philipsHueOAuth2Api: {
            tokenType: 'Bearer',
        },
        raindropOAuth2Api: {
            includeCredentialsOnRefreshOnBody: true,
        },
        shopifyOAuth2Api: {
            tokenType: 'Bearer',
            keyToIncludeInAccessTokenHeader: 'X-Shopify-Access-Token',
        },
        slackOAuth2Api: {
            tokenType: 'Bearer',
            property: 'authed_user.access_token',
        },
        stravaOAuth2Api: {
            includeCredentialsOnRefreshOnBody: true,
        },
    };
    return oAuth2Options[nodeCredentialType];
};
exports.getOAuth2AdditionalParameters = getOAuth2AdditionalParameters;
exports.binaryContentTypes = [
    'image/',
    'audio/',
    'video/',
    'application/octet-stream',
    'application/gzip',
    'application/zip',
    'application/vnd.rar',
    'application/epub+zip',
    'application/x-bzip',
    'application/x-bzip2',
    'application/x-cdf',
    'application/vnd.amazon.ebook',
    'application/msword',
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    'application/vnd.ms-fontobject',
    'application/vnd.oasis.opendocument.presentation',
    'application/pdf',
    'application/x-tar',
    'application/vnd.visio',
    'application/vnd.ms-excel',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    'application/x-7z-compressed',
];
async function reduceAsync(arr, reducer, init = Promise.resolve({})) {
    return arr.reduce(async (promiseAcc, item) => {
        return reducer(await promiseAcc, item);
    }, init);
}
exports.reduceAsync = reduceAsync;
const prepareRequestBody = async (parameters, bodyType, version, defaultReducer) => {
    if (bodyType === 'json' && version >= 4) {
        return parameters.reduce(async (acc, entry) => {
            const result = await acc;
            (0, set_1.default)(result, entry.name, entry.value);
            return result;
        }, Promise.resolve({}));
    }
    else {
        return reduceAsync(parameters, defaultReducer);
    }
};
exports.prepareRequestBody = prepareRequestBody;
//# sourceMappingURL=GenericFunctions.js.map